"""
将多个 module 的输入/输出 tensor 追加保存到指定 .pt 文件。
每条记录包含：module 名、参数名（input/output）、tensor。
"""
import torch
from pathlib import Path
from typing import Union, Literal


def append_module_io(
    tensor: torch.Tensor,
    module_name: str,
    io_kind: Literal["input", "output"],
    file_path: Union[str, Path],
) -> None:
    """
    将单个 module 的输入或输出 tensor 追加到 .pt 文件。

    Args:
        tensor: 该 module 的输入或输出 tensor。
        module_name: 模块名，如 "model.layers.0.self_attn"。
        io_kind: "input" 或 "output"。
        file_path: .pt 文件路径，如 "module_io.pt"。
    """
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)

    record = {
        "module": module_name,
        "param_name": io_kind,
        "tensor": tensor.detach().cpu(),
    }

    if file_path.exists():
        data = torch.load(file_path, map_location="cpu", weights_only=False)
        if not isinstance(data, list):
            data = [data]
    else:
        data = []
    data.append(record)
    torch.save(data, file_path)


def append_module_io_batch(
    records: list[tuple[torch.Tensor, str, Literal["input", "output"]]],
    file_path: Union[str, Path],
) -> None:
    """
    批量追加多条「module 输入/输出」到同一 .pt 文件。
    records: [(tensor, module_name, "input"|"output"), ...]
    """
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)

    if file_path.exists():
        data = torch.load(file_path, map_location="cpu", weights_only=False)
        if not isinstance(data, list):
            data = [data]
    else:
        data = []

    for tensor, module_name, io_kind in records:
        data.append({
            "module": module_name,
            "param_name": io_kind,
            "tensor": tensor.detach().cpu(),
        })
    torch.save(data, file_path)
